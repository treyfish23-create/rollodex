// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  MASTER
  USER
}

enum AccessRequestStatus {
  PENDING
  APPROVED
  DENIED
  REVOKED
}

enum AccessType {
  FULL
  ASSETS_ONLY
}

enum AssetCategory {
  LOGO
  PRODUCT
  CAMPAIGN
}

enum NotificationType {
  ACCESS_REQUEST
  ACCESS_APPROVED
  ACCESS_DENIED
  NEW_ASSETS
  SUBSCRIPTION_UPDATE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  PAST_DUE
  UNPAID
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  role      UserRole @default(USER)
  companyId String
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  notifications Notification[]
  notes         Note[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("users")
}

model Company {
  id                    String             @id @default(cuid())
  name                  String
  subscriptionStatus    SubscriptionStatus @default(UNPAID)
  stripeCustomerId      String?            @unique
  stripeSubscriptionId  String?            @unique
  subscriptionEndsAt    DateTime?
  
  users                 User[]
  brand                 Brand?
  accessRequests        AccessRequest[]    @relation("RequesterCompany")
  notes                 Note[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("companies")
}

model Brand {
  id          String  @id @default(cuid())
  name        String
  about       String?
  website     String?
  contactInfo String?
  socialLinks Json?   // Store as JSON: {instagram: "", linkedin: "", etc}
  
  companyId   String  @unique
  company     Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  assets             Asset[]
  receivedAccessRequests AccessRequest[] @relation("TargetBrand")
  notes              Note[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("brands")
}

model Asset {
  id           String        @id @default(cuid())
  filename     String        // S3 key
  originalName String        // Original uploaded filename
  fileType     String        // MIME type
  size         Int           // File size in bytes
  category     AssetCategory
  
  // Product-specific fields
  productName  String?
  description  String?
  tags         String[]      // Array of tags
  
  brandId      String
  brand        Brand         @relation(fields: [brandId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  
  @@map("assets")
}

model AccessRequest {
  id                 String              @id @default(cuid())
  requesterCompanyId String
  targetBrandId      String
  status             AccessRequestStatus @default(PENDING)
  accessType         AccessType          @default(FULL)
  message            String?             // Optional message from requester
  
  requesterCompany   Company @relation("RequesterCompany", fields: [requesterCompanyId], references: [id], onDelete: Cascade)
  targetBrand        Brand   @relation("TargetBrand", fields: [targetBrandId], references: [id], onDelete: Cascade)
  
  createdAt          DateTime @default(now())
  approvedAt         DateTime?
  
  @@unique([requesterCompanyId, targetBrandId])
  @@map("access_requests")
}

model Note {
  id        String  @id @default(cuid())
  content   String
  brandId   String
  companyId String  // Which company wrote the note
  authorId  String  // Which user wrote the note
  
  brand     Brand   @relation(fields: [brandId], references: [id], onDelete: Cascade)
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  author    User    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("notes")
}

model Notification {
  id          String           @id @default(cuid())
  type        NotificationType
  title       String
  content     String
  read        Boolean          @default(false)
  recipientId String
  
  recipient   User @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  
  @@map("notifications")
}
